---
layout: post
title: 객체 지향 프로그래밍
category: ComputerScience
---
### 정의

객체 지향의 가장 기본은 객체이다. 객체의 핵심은 기능을 제공하는 것이다. 객체를 정의할 때 내부적으로  어떤 데이터를 가지고 있는지가 아닌 제공할 기능을 정의해야 한다. 이러한 객체의 기능들을 오퍼레이션이라 부른다.

즉, 객체는 오퍼레이션으로 정의된다.

### 시그니처

오퍼레이션의 사용법을 구성하는 것이다.

1. 파라미터 및 파라미터 타입
2. 기능 식별 이름
3. 기능 실행 결과 값 및 타입

### 인터페이스

객체가 제공하는 모든 오퍼레이션 집합을 객체의 인터페이스라고 부른다. JAVA 언어에서의 인터페이스와는 다르며 객체를 사용하기 위한 명세를 의미한다.

### 메시지

오퍼레이션의 실행을 요청하는 것을 메시지를 보낸다고 표현하며 메소드를 호출하는 것이 메시지를 보내는 과정에 해당됩니다.

### 책임

객체는 자기가 가진 기능에 대한 책임을 가지게 됩니다. 하나의 객체가 많은 기능을 포함하여 많은 책임을 가지게 되는것은 절차 지향 프로그래밍과 다를바 없게 됩니다. 그래서 객체가 적은 기능을 가지고 책임의 크기가 작을 수록 프로그래밍이 유연해집니다. 이것이 단일 책임 원칙(SRP) 입니다.

> 단일 책임 원칙
>
> 하나의 객체는 하나의 책임만을 가져야 합니다.

### 의존성

객체가 다른 객체를 사용하는것을 의존한다고 할 수 있습니다. 의존의 의존을 거듭하다 보면 의존의 영향 때문에 객체를 변화될 수 있다. 하지만 이런 문제를 막기위해 의존역전 법칙(DIP)을 지켜야 합니다.

> 의존 역전 법칙
>
> 고차원 모듈은 저차원의 모듈에 의존하면 안되며, 이 모듈은 모두 다른 추상화된 것에 의존해야한다.
>
> 자신보다 변하기 쉬운 것에 의존하는 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향을 받지 않게 하는 것이다.

 ### 캡슐화

객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것이다. 내부 기능 구현이 변경 되더라도, 그 기능을 사용하는 코드는 영향을 받지 않도록 해준다. 내부 구현 변경의 유연함을 주는 기법이 캡슐화이다.

즉, 객체 내부를 보호함으로써 외부의 잘못된 사용으로 인해 객체가 손상되는 것을 막는 것이다.

> 캡슐화를 위한 2가지 규칙
>
> 1. Tell, Don't ask
>
>    데이터를 묻지 말고 기능을 실행하라는 의미이다. 데이터를 읽는 대신 메소드를 통해 데이터에 접근해야 한다.
>
> 2. 데미테르 법칙
>
>    메서드에서 생성한 객체의 메서드만 호출
>
>    파라미터로 받은 객체의 메서드만 호출
>
>    필드로 참조하는 객체의 메서드만 호출

### 상속

상속을 통한 재사용의 단점

1. 상위 클래스 변경의 어려움

   상위 클래스를 상속한 하위 클래스에 영향을 줄 수 있기 때문이다.

2. 클래스의 불필요한 증가

   유사한 기능을 확장하는 과정에서 클래스의 개수가 불필요하게 증가할 수 있다.

3. 상속의 오용

   같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면 잘못된 사용으로 인한 문제가 발생한다.

이와 같이 상속으로 인해 생기는 문제점을 해결할 수 있는 방법이 **객체 조립** 입니다.

객체 조립이란 보통 필드에서 다른 객체를 참조하는 방식으로 구현됩니다.

상속에 비해 조립을 통한 재상용의 단점은 런타임 구조가 복잡해지며 구현이 어렵습니다.

구현/구조의 복잡함보다 변경의 유연함을 확보하데서 오는 장점이 크기때문에, 상속보다 먼저 고려해보아야 하는 방법입니다.

상속은 재사용의 관점에서가 아닌 기능의 확장의 관점에서 이루어져야 합니다. 그리고 IS-A관계가 성립되어야 합니다.

> IS-A 관계란?
>
> `~는 ~이다.` 가 성립되는 관계를 의미하며, 부모 클래스를 상속받아 자식 클래스를 만든다고 할때, `자식 클래스는 부모 클래스이다.`가 성립되는 관계입니다.
>
> 예를 들면, 포유류를 부모 클래스 개를 자식클래스라고 하면 개는 포유류로부터 모든 특징을 상속을 받습니다. 그리고 `개는 포유류입니다. `가 성립됨을 볼 수 있습니다.

### 객체 지향적 설계 원칙

> SOLID

SRP : 단일 책임 원칙

OCP : 개방 - 폐쇄 원칙

LSP : 리스코프 치환 원칙

ISP : 인터페이스 분리 원칙

DIP : 의존 역전 원칙

#### 단일 책임원칙

클래스는 단 하나의 책임을 가져야 합니다.

#### 개방-폐쇄 원칙

확장에는 열려있어야 하며 변경에는 닫혀 있어야 합니다.

#### 리스코프 치환 원칙

상위 타입의 객체를 하위 타입의 객체로 치환하여도 상위 타입을 사용하는 프로그램은 정상 작동 해야 합니다.

#### 인터페이스 분리 원칙

인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리 해야 한다. 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 사용되는 인터페이스에 영향을 받지 않도록 해야 한다.

#### 의존 역전 원칙

고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.



### 클래스

클래스는 객체를 만드는 설계도이다. 메소드와 필드로 구성됩니다.

#### 인스턴스

인스턴스는 클래스를 이용해 선언되어 메모리에 할당된 객체를 의미 합니다.

#### 메소드

어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있습니다.

```
접근제어자 반환타입 메소드이름(매개변수목록){
   // 구현
}
```

접근제어자 : 해당 메소드에 접근할 수 있는 범위 지정

반환 타입: 반환하는 데이터 타입을 명시

구현 : 메소드의 고유 기능을 수행하는 명령문의 집합

> 메소드 오버로딩
>
> 메소드를 정의할 때 같은 이름으로 중복하여 정의 할 수 없지만 메소드 오버로딩을 이용하면 중복하여 정의 할 수 있습니다.
>
> 매개 변수의 타입이나 갯수를 다르게 하여 같은 이름의 다른 메소드를 정의 할 수 있으며 사용되는 이름을 절약할 수 있고 메소드를 호출 할 때 전달할 매개변수의 타입이나 개수에 대해 신경쓰지 않아도 되는 장점이 있습니다.

